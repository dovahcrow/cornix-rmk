[keyboard]
name = "Cornix Keyboard"
product_name = "Cornix Keyboard"
vendor_id = 0xe11b
product_id = 0x0001
manufacturer = "cornix"
chip = "nrf52840"

[layout]
rows = 4
cols = 14
layers = 11
matrix_map = """
(0,0) (0,1) (0,2) (0,3) (0,4) (0,5)             (0,8) (0,9) (0,10) (0,11) (0,12) (0,13)
(1,0) (1,1) (1,2) (1,3) (1,4) (1,5)       (1,7) (1,8) (1,9) (1,10) (1,11) (1,12) (1,13)
(2,0) (2,1) (2,2) (2,3) (2,4) (2,5) (2,6)       (2,8) (2,9) (2,10) (2,11) (2,12) (2,13)
(3,0) (3,1) (3,2) (3,3) (3,4) (3,5)             (3,8) (3,9) (3,10) (3,11) (3,12) (3,13)
"""
# keymap = [
#     [
#         ["TAB" , "Q"   , "W"    , "E"   , "R"  , "T"  , "NO" , "NO" , "Y"  , "U"  , "I"  , "O"   , "P"   , "BSPC"],
#         ["ESC" , "A"   , "S"    , "D"   , "F"  , "G"  , "NO" , "NO" , "H"  , "J"  , "K"  , "L"   , "'"   , ";"   ],
#         ["UP"  , "Z"   , "X"    , "C"   , "V"  , "B"  , "SPC", "SPC", "N"  , "M"  , ","  , "."   , "/"   , "UP"  ],
#         ["DOWN", "LEFT", "RIGHT", "BSPC", "SPC", "ENT", "NO" , "NO" , "ENT", "SPC", "DEL", "LEFT", "DOWN", "RIGHT"],
#     ],
# ]

[aliases]
CLPBRD = "WM(V, LGUI | LSHIFT)"
OPWD = "WM(/, LGUI | LALT)"
SNPST_PIC = "WM(U, LSHIFT | LALT | LCTRL)"
SNPST_VID = "WM(O, LSHIFT | LALT | LCTRL)"
SNPST_REG = "WM(I, LSHIFT | LALT | LCTRL)"
LMDA = "LT(media, bspc)"
LNAV = "LT(nav, spc)"
LMSE = "LT(mouse, ent)"
LSYM = "LT(symbol, ent)"
LNUM = "LT(number, spc)"
LFUN = "LT(function, del)"

AR1 = "WM(Kc1, LCTRL | LALT)"
AR2 = "WM(Kc2, LCTRL | LALT)"
AR3 = "WM(Kc3, LCTRL | LALT)"
AR4 = "WM(Kc4, LCTRL | LALT)"
AR5 = "WM(Kc5, LCTRL | LALT)"
AR6 = "WM(Kc6, LCTRL | LALT)"
AR_LW   = "WM(H, LCTRL | LALT)"
AR_RW   = "WM(L, LCTRL | LALT)"
AR_FSCR = "WM(SPACE, LSHIFT | LALT)"
AR_ACC  = "WM(FSLH, LCTRL | LALT)"
AR_TIL  = "WM(COMMA, LCTRL | LALT)"

MAC_SLP ="WM(Q, LGUI | LCTRL)"

ED_PREV = "MT(O, LCTRL)"
ED_NEXT = "MT(I, LCTRL)"

LG1 = "WM(KC1, LGUI)"
LG2 = "WM(KC2, LGUI)"
LG3 = "WM(KC3, LGUI)"
LG4 = "WM(KC4, LGUI)"
LG5 = "WM(KC5, LGUI)"

PD_SPC = "WM(SPC, LCTRL | LALT | LSHIFT)"
PD_Q = "WM(Q, LCTRL | LALT | LSHIFT)"
PD_W = "WM(W, LCTRL | LALT | LSHIFT)"
PD_E = "WM(E, LCTRL | LALT | LSHIFT)"
PD_R = "WM(R, LCTRL | LALT | LSHIFT)"
PD_T = "WM(T, LCTRL | LALT | LSHIFT)"
PD_A = "WM(A, LCTRL | LALT | LSHIFT)"
PD_S = "WM(S, LCTRL | LALT | LSHIFT)"
PD_D = "WM(D, LCTRL | LALT | LSHIFT)"
PD_F = "WM(F, LCTRL | LALT | LSHIFT)"
PD_G = "WM(G, LCTRL | LALT | LSHIFT)"

[[layer]]
name = "base"
keys = """
TAB  Q          W          E           R            T                   Y     U            I           O          P          NO
ESC  MT(A,LGUI) MT(S,LALT) MT(D,LCTRL) MT(F,LSHIFT) G             @OPWD H     MT(J,LSHIFT) MT(K,LCTRL) MT(L,LALT) MT(',LGUI) ;
UP   Z          X          C           V            B     @CLPBRD       N     M            comm        .          /          @SNPST_PIC
DOWN LEFT       RIGHT      @LMDA       @LNAV        @LMSE               @LSYM @LNUM        @LFUN       LEFT       DOWN       RIGHT
"""

[[layer]]
name = "media"
keys = """
No No No No No No       No             @SNPST_PIC     @SNPST_REG @SNPST_VID     No No
No No No No No No    No MediaPrevTrack KbVolumeDown   KbVolumeUp MediaNextTrack No No
No No No No No No No    No             No             No         No             No No
No No No No No No       MediaStop      MediaPlayPause AudioMute  No             No No
"""

[[layer]]
name = "nav"
keys = """
@PD_SPC  @AR1   @AR2   @AR3   @AR4   @AR5         @AR6     @AR_LW   @AR_RW No    No     No
@AR_FSCR Macro0 Macro1 Macro2 Macro3 Macro4    No Left     Down     Up     Right Macro7 No
No       @LG1   @LG2   @LG3   @LG4   @LG5   No    Home     PageDown PageUp End   Macro6 No
No       No     No     No     No     No           @ED_PREV @ED_NEXT No     No    No     No
"""

[[layer]]
name = "mouse"
keys = """
@PD_SPC @PD_Q @PD_W @PD_E @PD_R @PD_T       MouseLeft      MouseDown MouseUp   MouseRight      No WM(BSPC, LALT)
No      @PD_A @PD_S @PD_D @PD_F @PD_G    No WM(LEFT, LALT) No        No        WM(RIGHT, LALT) No No
No      No    No    No    No    No    No    No             No        No        No              No No
No      No    No    No    No    No          WM(BSPC, LALT) MouseBtn1 MouseBtn2 No              No No
"""

[[layer]]
name = "symbol"
keys = """
No WM([, LSHIFT) WM(Kc1, LSHIFT) WM(Kc2, LSHIFT) WM(Kc3, LSHIFT) WM(], LSHIFT)        No No No No No No
No WM(;, LSHIFT) WM(Kc4, LSHIFT) WM(Kc5, LSHIFT) WM(Kc6, LSHIFT) WM(=, LSHIFT)     No No No No No No No
No WM(`, LSHIFT) WM(Kc7, LSHIFT) WM(Kc8, LSHIFT) WM(Kc9, LSHIFT) WM(\\, LSHIFT) No    No No No No No No
No No            No              WM(Kc9, LSHIFT) WM(Kc0, LSHIFT) WM(-, LSHIFT)        No No No No No No
"""

[[layer]]
name = "number"
keys = """
No [  Kc1 Kc2 Kc3 ]        No No No No No No
No ;  Kc4 Kc5 Kc6 =     No No No No No No No
No `  Kc7 Kc8 Kc9 \\ No    No No No No No No
No No No  .   0   -        No No No No No No
"""

[[layer]]
name = "function"
keys = """
User5 F10 F1 F2 F3 No       No No No No No @MAC_SLP
User0 F11 F4 F5 F6 No    No No No No No No No
User1 F12 F7 F8 F9 No No    No No No No No No
User2 No  No No No No       No No No No No No
"""

[storage]
clear_storage = true # rmk won't update keymap through reflash, need to force clear

[ble]
enabled = true

[light]
# All light pins are high-active by default, uncomment if you want it to be low-active
# capslock.pin = "P0_00"
# capslock.low_active = true
# numslock.pin = "P0_01"
# numslock.low_active = false

[behavior]
tap_hold = { enable_hrm = true, unilateral_tap = true, permissive_hold = true, prior_idle_time = "120ms", hold_timeout = "200ms" }

[behavior.combo]
timeout = "100ms"

[[behavior.combo.combos]]
actions = ["Z", "X"]
output = "WM(Z, LGUI)"
layer = 0

[[behavior.combo.combos]]
actions = ["X", "C"]
output = "WM(X, LGUI)"
layer = 0

[[behavior.combo.combos]]
actions = ["C", "V"]
output = "WM(C, LGUI)"
layer = 0

[[behavior.combo.combos]]
actions = ["V", "B"]
output = "WM(V, LGUI)"
layer = 0

[[behavior.combo.combos]]
actions = ["MT(F,LSHIFT)", "G"]
output = "WM(F, LGUI)"
layer = 0

[[behavior.combo.combos]]
actions = ["MT(A,LGUI)", "MT(S,LALT)"]
output = "WM(A, LGUI)"
layer = 0

[[behavior.macro.macros]]
operations = [
  { operation = "down", keycode = "M" }, 
  { operation = "down", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "up", keycode = "M" },
  { operation = "up", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "tap", keycode = "Kc1" },
]

[[behavior.macro.macros]]
operations = [
  { operation = "down", keycode = "M" }, 
  { operation = "down", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "up", keycode = "M" },
  { operation = "up", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "tap", keycode = "Kc2" },
]

[[behavior.macro.macros]]
operations = [
  { operation = "down", keycode = "M" }, 
  { operation = "down", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "up", keycode = "M" },
  { operation = "up", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "tap", keycode = "Kc3" },
]

[[behavior.macro.macros]]
operations = [
  { operation = "down", keycode = "M" }, 
  { operation = "down", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "up", keycode = "M" },
  { operation = "up", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "tap", keycode = "Kc4" },
]

[[behavior.macro.macros]]
operations = [
  { operation = "down", keycode = "M" }, 
  { operation = "down", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "up", keycode = "M" },
  { operation = "up", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "tap", keycode = "Kc5" },
]

[[behavior.macro.macros]]
operations = [
  { operation = "down", keycode = "M" }, 
  { operation = "down", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "up", keycode = "M" },
  { operation = "up", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "tap", keycode = "Kc6" },
]

[[behavior.macro.macros]]
operations = [
  { operation = "down", keycode = "M" }, 
  { operation = "down", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "up", keycode = "M" },
  { operation = "up", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "tap", keycode = "L" },
]

[[behavior.macro.macros]]
operations = [
  { operation = "down", keycode = "M" }, 
  { operation = "down", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "up", keycode = "M" },
  { operation = "up", keycode = "LALT" }, 
  { operation = "delay", duration = "30ms" },
  { operation = "tap", keycode = "[" },
]

# [[behavior.tap_dance.tap_dances]]
# tap = "A"
# hold = "WM(A, LShift)"
# double_tap = "CapsLock"
# hold_after_tap = "A"
# timeout = "150ms"

# [[behavior.tap_dance.tap_dances]]
# tap = "Space"
# hold = "LCtrl"

# [[behavior.tap_dance.tap_dances]]
# tap_actions = ["F1", "F2", "F3", "F4"]  # 1 tap = F1, 2 taps = F2, 3 taps = F3, 4 taps = F4
# hold_actions = ["MO(1)", "MO(2)", "MO(3)", "MO(4)"]  # Hold after 1 tap = layer 1, etc.
# timeout = "200ms"

# [[behavior.tap_dance.tap_dances]]
# tap_actions = ["Tab", "Escape", "CapsLock"]  # 1 tap = Tab, 2 taps = Escape, 3 taps = CapsLock
# hold_actions = ["LCtrl", "LAlt", "LShift"]  # Hold after 1 tap = Ctrl, etc.
# timeout = "250ms"

[split]
connection = "ble"

[split.central]
rows = 4
cols = 7
row_offset = 0
col_offset = 0
ble_addr = [0x18, 0xe2, 0x21, 0x80, 0xc0, 0xc7]

[split.central.matrix]
matrix_type = "normal"
input_pins = ["P0_30", "P0_31", "P0_29", "P0_02"]
output_pins = ["P0_28", "P0_03", "P1_10", "P1_11", "P1_13", "P0_09", "P0_10",]

[[split.central.input_device.encoder]]
pin_a = "P1_04"
pin_b = "P1_06"
phase = "default"
resolution = 2
reverse = false

[[split.peripheral]]
rows = 4
cols = 7
row_offset = 0
col_offset = 7
ble_addr = [0x7e, 0xfe, 0x73, 0x9e, 0x66, 0xe3]

[split.peripheral.matrix]
matrix_type = "normal"
input_pins = ["P1_09", "P0_28", "P0_03", "P1_10"]
output_pins = ["P0_09", "P0_10", "P1_13", "P0_02", "P0_29", "P0_31", "P0_30", ] # The pin is reversed

[[split.peripheral.input_device.encoder]]
pin_a = "P1_04"
pin_b = "P1_06"

# Working mode of the encoder
# Available modes:
# - default: EC11 compatible mode, resolution = 1
# - e8h7: resolution = 2, direction reversed
# - resolution: custom resolution, requires specifying resolution and reverse parameters
phase = "default"

# Resolution represents the number of pulses generated per detent
# For example: if your encoder has 30 detents and generates 15 pulses per 360-degree rotation, then resolution = 30/15 = 2
# The number of detents and pulses can be found in your encoder's datasheet
resolution = 2

# Whether to reverse the encoder direction
reverse = false

[security]
# For example, the unlock keys are the combo of
# the row 0, col 0 key and the row 0, col 1 key
unlock_keys = [[0, 0], [0, 1]]
